<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>文章页</title>
  <link type="text/css" rel="stylesheet" href="assets/fonts/css/font-awesome.css"/>
  <link type="text/css" rel="stylesheet" href="assets/bootstrap/bootstrap.css"/>
  <link type="text/css" rel="stylesheet" href="assets/app/css/app.min.css?ver=1153"/>
</head>
<body class="post-template"> <!-- 添加 .post-template 以便识别模板为文章页 -->
<div class="site-warp">
  <header class="site-header fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark">
      <div class="container">
        <a class="navbar-brand" href="/">淮城一只猫</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item active">
              <a class="nav-link" href="#">
                首页
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#">友联</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#">关于</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
  </header>
  <section class="site-hero responsive-title-no-img"> <!-- 没有图片 添加 .responsive-title-no-img -->
    <div class="container">
      <div class="hero-content">
        <h1 class="post-full-title">淮城一只猫</h1>
        <section class="post-full-meta">
          <time class="post-full-meta-date" datetime="2018-10-02">2018年10月02日</time>
          <span class="date-divider">/</span>
          <a href="#">生活杂记</a>
          <span class="date-divider">/</span>
          <span class="post-full-meta-visitors">
            <i class="post-meta-item-text">阅读量 </i>
            <i class="leancloud-visitors-count">259</i>
          </span>
        </section>
      </div>
    </div>
  </section>
  <main class="site-main container">
    <div class="inner row">
      <article>
        <section class="post-content">
          <!--删除下面测试数据--><!--删除下面测试数据--><!--删除下面测试数据--><!--删除下面测试数据--><!--删除下面测试数据--><!--删除下面测试数据--><!--删除下面测试数据-->
          <h3 id="前言">前言</h3>
          <p>续上篇文章 <a href="https://iiong.com/nodejs-back-end-development-notes-follow-up-1/">Node.js 后端开发笔记后续 - 1</a> 利用 <code>Sequelize-Cli</code> 工具已经完成表结构设计以及数据填充，下面使用 <code>Sequelize</code> 插件库本身的数据模型 <code>model</code> 的查询能力来实现表查询。</p>
          <h3 id="sequelize-连接-mysql-数据库">Sequelize 连接 MySQL 数据库</h3>
          <p><code>Sequelize</code> 连接数据库的核心代码主要就是通过 <code>new Sequelize</code>（<code>database</code>, <code>username</code>, <code>password</code>, <code>options</code>） 来实现，其中 <code>options</code> 中的配置选项，除了最基础的 <code>host</code> 与 <code>port</code>、数据库类型外，还可以设置连接池的连接参数 <code>pool</code>，数据模型命名规范 <code>underscored</code> 等等。</p>
          <p>之前使用 <code>cli</code> 工具初始化 <code>models</code> 目录，里面包含数据库表模型入口模块，希望遵循 MySQL 数据库表字段的下划线命名规范，所以，需要全局开启一个 <code>underscore: true</code> 的定义，来使系统中默认的 <code>createdAt</code> 与 <code>updatedAt</code> 能以下划线的方式，与表结构保持一致。修改下 <code>model/index.js</code> 文件：</p>
          <pre><code class="language-javascript">const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const Sequelize = require(&#39;sequelize&#39;);
const configs = require(&#39;../config/config.js&#39;);
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || &#39;development&#39;;
const config = {
    ...configs[env],
    define: {
        underscored: true,
    }
};
const db = {};

let sequelize;
if (config.use_env_variable) {
    sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
    sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs.readdirSync(__dirname).filter(file =&gt; {
    return (file.indexOf(&#39;.&#39;) !== 0) &amp;&amp; (file !== basename) &amp;&amp; (file.slice(-3) === &#39;.js&#39;);
}).forEach(file =&gt; {
    const model = sequelize[&#39;import&#39;](path.join(__dirname, file));
    db[model.name] = model;
});

Object.keys(db).forEach(modelName =&gt; {
    if (db[modelName].associate) {
        db[modelName].associate(db);
    }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;</code></pre>
          <h3 id="定义数据库业务相关的-model">定义数据库业务相关的 model</h3>
          <p>在项目中我创建个事项清单表设计，根据上诉生成的文件：</p>
          <pre><code class="language-javascript">module.exports = {
  up: (queryInterface, Sequelize) =&gt; {
    return queryInterface.createTable(&#39;todos&#39;, {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        primaryKey: true,
        comment: &#39;主键&#39;,
      },
      content: {
        type: Sequelize.STRING,
        allowNull: false,
        comment: &#39;事项清单内容描述&#39;,
      },
      user_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        comment: &#39;关联 users 表用户id&#39;,
      },
      is_complete: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        comment: &#39;是否已经完成事项清单&#39;,
      },
      created_at: {
        type: Sequelize.DATE,
        comment: &#39;事项清单创建时间&#39;,
      },
    });
  },

  down: (queryInterface, Sequelize) =&gt; {
    return queryInterface.dropTable(&#39;todos&#39;);
  }
};</code></pre>
          <p>迁移导入即可，结合业务所需在 <code>models</code> 目录下继续创建一系列的 <code>model</code> 来与数据库表结构做对应：</p>
          <pre><code class="language-bash">├── models                       # 数据库 model
│   ├── index.js                 # model 入口与连接
│   ├── users.js                 # 用户表
│   ├── todos.js                 # 事项清单表</code></pre>
          <p><strong>定义用户的数据模型 users</strong></p>
          <pre><code class="language-javascript">module.exports = (sequelize, DataTypes) =&gt; sequelize.define(
    &#39;users&#39;,
    {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true,
        },
        name: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        avatar: DataTypes.STRING,
    },
    {
        tableName: &#39;users&#39;,
    }
);</code></pre>
          <p><strong>定义事项清单的数据模型 todos</strong></p>
          <pre><code class="language-javascript">module.exports = (sequelize, DataTypes) =&gt; sequelize.define(
    &#39;todos&#39;,
    {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true,
        },
        content: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        user_id: {
            type: DataTypes.INTEGER,
            allowNull: false,
        },
        is_complete: {
            type: DataTypes.BOOLEAN,
            allowNull: false,
        },
    },
    {
        tableName: &#39;todos&#39;,
    }
);</code></pre>
          <h3 id="实现用户列表接口">实现用户列表接口</h3>
          <p><strong>简单实现用户列表接口</strong></p>
          <pre><code class="language-javascript">const Joi = require(&#39;@hapi/joi&#39;);
const models = require(&quot;../models&quot;);

const GROUP_NAME = &#39;users&#39;;

module.exports = [
    {
        method: &#39;GET&#39;,
        path: `/${GROUP_NAME}`,
        options: {
            handler: async (request, h) =&gt; {
                // 通过 await 来异步查取数据
                return await models.users.findAll();
            },
            description: &#39;获取用户列表&#39;,
            notes: &#39;这是获取用户列表信息展示笔记&#39;,
            tags: [&#39;api&#39;, GROUP_NAME]
        },
    }
];</code></pre>
          <p><strong>隐藏返回列表中不需要的字段</strong></p>
          <p>如果项目并不希望 <code>findAll</code> 来将数据表中的所有数据全都暴露出来，比如在查询用户列表时，用户的密码的值，便是特别敏感的数据。 项目可以在 <code>findAll</code> 中加入一个 <code>attributes</code> 的约束，可以是一个要查询的属性（字段）列表，或者是一个 <code>key</code> 为 <code>include</code> 或 <code>exclude</code> 对象的键，比如对于用户表，<code>findAll({ attributes: { exclude: [&#39;password&#39;] } })</code>，就可以排除密码字段的查询露出。</p>
          <p>下面隐藏用户的更新时间和创建时间的字段，只显示 <code>id</code> <code>name</code> <code>avatar</code>：</p>
          <pre><code class="language-javascript">const Joi = require(&#39;@hapi/joi&#39;);
const models = require(&quot;../models&quot;);

const GROUP_NAME = &#39;users&#39;;

module.exports = [
    {
        method: &#39;GET&#39;,
        path: `/${GROUP_NAME}`,
        options: {
            handler: async (request, h) =&gt; {
                // 通过 await 来异步查取数据
                return await models.users.findAll({
                    attributes: [
                        &#39;id&#39;, &#39;name&#39;, &#39;avatar&#39;
                    ]
                });
            },
            description: &#39;获取用户列表&#39;,
            notes: &#39;这是获取用户列表信息展示笔记&#39;,
            tags: [&#39;api&#39;, GROUP_NAME]
        },
    }
];</code></pre>
          <p>再次访问接口，发现功能已经实现了。</p>
          <p><strong>列表分页</strong></p>
          <p>当数据很多的时候，分页也是个很重要的业务，实现这个业务很简单，同样可以利用 <code>hapi-pagination</code> 插件来完成需求。</p>
          <pre><code class="language-bash">npm install hapi-pagination --save # 安装插件</code></pre>
          <p>在 <code>plugins</code> 目录下新增一个 <code>hapi-pagination</code> 的插件。<code>options</code> 的具体配置参数细节说明，参见 <a href="https://github.com/fknop/hapi-pagination">hapi-pagination</a>。</p>
          <pre><code class="language-javascript">const hapiPagination = require(&#39;hapi-pagination&#39;);

const options = {
    query: {
        // 按页面划分的资源数量。默认值为25，默认名称为limit
        limit: {
            name: &#39;limit&#39;,
            default: 25
        },
        // 将返回的页面数。默认值为1，默认名称为page
        page: {
            name: &#39;page&#39;,
            default: 1
        },
        // 是否开启分页功能，默认 true
        pagination: {
            name: &#39;pagination&#39;,
            default: true,
            active: true
        },
        // 无效返回结果
        invalid: &#39;defaults&#39;,
    },
    meta: {
        name: &#39;meta&#39;,
        // ... 此处篇幅考虑省略 meta 的相关配置代码，参看章节  github 案例
    },
    results: {
        name: &#39;results&#39;
    },
    reply: {
        paginate: &#39;paginate&#39;
    },
    routes: {
        include: [
            &#39;/users&#39;  // 用户列表支持分页特性
        ],
        exclude: []
    }
};

module.exports = {
    plugin: hapiPagination,
    options: options,
};
</code></pre>
          <p>在 <code>app.js</code> 中注册使用 <code>hapi-pagination</code>：</p>
          <pre><code class="language-javascript">// 引入自定义的 hapi-pagination 插件配置
const pluginHapiPagination = require(&#39;./plugins/hapi-pagination&#39;);

// 注册插件
await server.register([
    // 为系统使用 hapi-swagger
    ...pluginHapiSwagger,
    // 为系统使用 hapi-pagination
    pluginHapiPagination,
]);
</code></pre>
          <p>为 <code>GET /users</code> 的接口添加分页的入参校验，同时更新 <code>Swagger</code> 文档的入参契约。考虑到系统中未来会有不少接口需要做分页处理，在 <code>utils/router-helper.js</code> 中增加一个公共的分页入参校验配置：</p>
          <pre><code class="language-javascript">const Joi = require(&#39;@hapi/joi&#39;);

const paginationDefine = {
    limit: Joi.number().integer().min(1).default(10).description(&#39;每页的条目数&#39;),
    page: Joi.number().integer().min(1).default(1).description(&#39;页码数&#39;),
    pagination: Joi.boolean().description(&#39;是否开启分页，默认为true&#39;),
};

module.exports = {paginationDefine};
</code></pre>
          <p>回到 <code>router/users.js</code>，实现最后的分页配置逻辑。考虑到分页的查询功能除了拉取列表外，还要获取总条目数，<code>Sequelize</code> 提供了 <code>findAndCountAll</code> 的 <code>API</code>，来为分页查询提供更高效的封装实现，返回的列表与总条数会分别存放在 <code>rows</code> 与 <code>count</code> 字段的对象中。</p>
          <pre><code class="language-javascript">const models = require(&quot;../models&quot;);
const { paginationDefine } = require(&#39;../utils/router-helper&#39;);

const GROUP_NAME = &#39;users&#39;;

module.exports = [
    {
        method: &#39;GET&#39;,
        path: `/${GROUP_NAME}`,
        options: {
            handler: async (request, h) =&gt; {
                const { rows: results, count: totalCount } = await models.users.findAndCountAll({
                    attributes: [
                        &#39;id&#39;, &#39;name&#39;, &#39;avatar&#39;
                    ],
                    limit: request.query.libraries,
                    offset: (request.query.page - 1) * request.query.limit,
                });

                return {results, totalCount}
            },
            auth: false,
            description: &#39;获取用户列表&#39;,
            notes: &#39;这是获取用户列表信息展示笔记&#39;,
            tags: [&#39;api&#39;, GROUP_NAME],
            validate: {
                query: {
                    ...paginationDefine
                }
            }
        },
    },
];
</code></pre>
          <p>通过 <code>Swagger</code> 文档工具 <a href="http://localhost:3000/documentation">http://localhost:3000/documentation</a> 查看用列表的接口调用返回数据，以及调用所需要的参数信息。</p>
          <h3 id="关联表数据查询">关联表数据查询</h3>
          <p>之前新建个 <code>todos</code> 表，里面包含用户 <code>id</code> 字段，下面尝试利用某个用户 <code>id</code> 去查询事项清单的列表信息，同样也需要支持分页信息展示：</p>
          <pre><code class="language-javascript">const Joi = require(&quot;@hapi/joi&quot;);
const models = require(&quot;../models&quot;);
const { paginationDefine } = require(&#39;../utils/router-helper&#39;);

const GROUP_NAME = &#39;users&#39;;

module.exports = [
    {
        method: &#39;GET&#39;,
        path: `/${GROUP_NAME}`,
        options: {
            handler: async (request, h) =&gt; {
                const { rows: results, count: totalCount } = await models.users.findAndCountAll({
                    attributes: [
                        &#39;id&#39;, &#39;name&#39;, &#39;avatar&#39;
                    ],
                    limit: request.query.libraries,
                    offset: (request.query.page - 1) * request.query.limit,
                });

                return {results, totalCount}
            },
            auth: false,
            description: &#39;获取用户列表&#39;,
            notes: &#39;这是获取用户列表信息展示笔记&#39;,
            tags: [&#39;api&#39;, GROUP_NAME],
            validate: {
                query: {
                    ...paginationDefine
                }
            }
        },
    },
    {
        method: &#39;GET&#39;,
        path: `/${GROUP_NAME}/{userId}/todos`,
        options: {
            handler: async (request, h) =&gt; {
                const { rows: results, count: totalCount } = await models.todos.findAndCountAll({
                    // 基于 user_id 的条件查询
                    where: {
                        user_id: request.params.userId
                    },
                    attributes: [
                        &#39;id&#39;, &#39;content&#39;, &#39;is_complete&#39;, &#39;created_at&#39;
                    ],
                    limit: request.query.libraries,
                    offset: (request.query.page - 1) * request.query.limit,
                });

                return {results, totalCount}
            },
            auth: false,
            description: &#39;获取某个用户事项清单列表&#39;,
            notes: &#39;这是获取某个用户事项清单列表信息展示笔记&#39;,
            tags: [&#39;api&#39;, GROUP_NAME],
            validate: {
                params: {
                    userId: Joi.number().integer().required().description(&#39;用户id&#39;),
                },
                query: {
                    ...paginationDefine
                }
            }
        },
    },
];
</code></pre>
          <p>同样在 <code>plugins/hapi-pagination.js</code> 添加白名单路由：</p>
          <pre><code class="language-javascript">//......
    routes: {
        include: [
            &#39;/users&#39;,  // 用户列表支持分页特性
            &#39;/users/{user_id}/todos&#39;,
        ],
    }
//......
</code></pre>
          <p>更多关于 models 的操作请查看官方手册 <a href="http://docs.sequelizejs.com/manual/models-usage.html">Model 使用</a></p>
          <h3 id="身份验证实现">身份验证实现</h3>
          <p>这里的项目使用当今主流的 <code>JWT</code> 验证身份方案，<code>JWT</code> 全称 <code>JSON Web Token</code>，是为了方便在各系统之间安全地传送 <code>JSON</code> 对象格式的信息，而采用的一个开发标准，基于 <code>RFC 7519</code> 定义。服务器在接收到 <code>JWT</code> 之后，可以验证它的合法性，用户登录与否的身份验证便是 <code>JWT</code> 的使用场景之一。具体原理和设计内容请参考：<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程</a></p>
          <p><strong>基于 JWT 的通用身份验证流程</strong></p>
          <p>在实际的项目应用场景中，<code>JWT</code> 的身份验证流程大致如下：</p>
          <ol>
            <li>用户使用用户名密码、或第三方授权登录后，请求应用服务器；</li>
            <li>服务器验证用户信息是否合法；</li>
            <li>对通过验证的用户，签发一个包涵用户 ID、其他少量用户信息（比如用户角色）以及失效时间的 <code>JWT token</code>；</li>
            <li>客户端存储 <code>JWT token</code>，并在调用需要身份验证的接口服务时，带上这个 <code>JWT token</code> 值；</li>
            <li>服务器验证 <code>JWT token</code> 的签发合法性，时效性，验证通过后，返回业务数据。</li>
          </ol>
          <p><strong>使用 jsonwebtoken 签发 JWT</strong></p>
          <p><a href="https://github.com/auth0/node-jsonwebtoken">jsonwebtoken</a> 是 <code>Node.js</code> 生态里用于签发与校验 <code>JWT</code> 的流行插件，这里需要该插件来完成 <code>JWT</code> 字符串的生成签发。</p>
          <pre><code class="language-bash">npm i jsonwebtoken --save # 安装插件
</code></pre>
          <p>根据文档得知 <code>JWT</code> 的签发语法是 <code>jwt.sign(payload, secretOrPrivateKey, [options, callback])</code>。默认的签发算法基于 <code>HS256 (HMAC SHA256)</code>，可以在 <code>options</code> 参数的 <code>algorithm</code> 另行修改。<code>JWT</code> 签发规范中的一些标准保留字段比如 <code>exp</code>，<code>nbf</code>，<code>aud</code>，<code>sub</code>，<code>iss</code> 等都没有默认值，可以一并在 payload 参数中按需声明使用，亦可以在第三个参数 <code>options</code> 中，通过 <code>expiresIn</code>，<code>notBefore</code>，<code>audience</code>，<code>subject</code>，<code>issuer</code> 来分别赋值，但是不允许在两处同时声明。</p>
          <p>下面是一个最简单的默认签发，1 小时后失效。</p>
          <pre><code class="language-javascript">const jwt = require(&#39;jsonwebtoken&#39;);
// 签发一条 1 小时后失效的 JWT
const token = jwt.sign(
  {
    foo: &#39;bar&#39;,
    exp: Math.floor(Date.now() / 1000) + (60 * 60),
  },
  &#39;your-secret&#39;
);
</code></pre>
          <p><strong>实现接口 POST /users/createJWT</strong></p>
          <p>实际应用中的 <code>JWT</code> 签发会把便于识别用户的 <code>userId</code> 的信息，签发在 <code>payload</code> 中，并同时给予一个失效时间。继续完善 <code>route/users.js</code> 路由，增加一个 <code>JWT</code> 测试性质的签发接口定义 <code>POST</code> <code>/users/createJWT</code>：</p>
          <pre><code class="language-javascript">const JWT = require(&#39;jsonwebtoken&#39;);
const env = require(&#39;../dotenv&#39;);

const GROUP_NAME = &#39;users&#39;;

module.exports = [
    {
        method: &#39;post&#39;,
        path: `/${GROUP_NAME}/createJWT`,
        options: {
            handler: async (request, h) =&gt; {
                const generateJWT = (jwtInfo) =&gt; {
                    const payload = {
                        userId: jwtInfo.userId,
                        exp: Math.floor(new Date().getTime() / 1000) + 7 * 24 * 60 * 60,
                    };
                    return JWT.sign(payload, env.JWT_SECRET);
                };
                return generateJWT({
                    userId: 1,
                })
            },
            auth: false, // 约定此接口不参与 JWT 的用户验证，会结合下面的 hapi-auth-jwt 来使用
            description: &#39;用于测试的用户 JWT 签发&#39;,
            notes: &#39;这是用于测试的用户 JWT 签发信息展示笔记&#39;,
            tags: [&#39;api&#39;, &#39;test&#39;],
        },
    },
];
</code></pre>
          <blockquote>
            <p>jwt.sign 的第二个参数 secret 是一个重要的敏感信息，可以通过 .env 的配置 JWT_SECRET 来分离。</p>
            <p>Secret 的秘钥签发，可以通过一些在线的 AES 加密工具来生成一串长度 32 或 64 的随机字符串。比如： <a href="http://tool.oschina.net/encrypt/">http://tool.oschina.net/encrypt/</a> 。太长的字符串会一定程度上影响 jwt 验证的计算效率，所以找寻一个平衡点为宜。</p>
          </blockquote>
          <p>访问 <code>swagger-ui</code> 测试 <code>JWT</code> 签发，可以得到 <code>JWT</code> 的测试签发结果，通过 <a href="https://jwt.io/">jwt.io</a> 来 <code>decode JWT</code> 中的 <code>payload</code> 信息，看能否拿到 <code>userId</code>。</p>
          <p><strong>hapi-auth-jwt2 接口用户验证</strong></p>
          <p>通过 <a href="https://github.com/dwyl/hapi-auth-jwt2">hapi-auth-jwt2</a> 插件，来赋予系统中的部分接口，需要用户登录授权后才能访问的能力。</p>
          <pre><code class="language-bash">npm install hapi-auth-jwt2 --save # 安装插件
</code></pre>
          <p>配置插件 <code>plugins/hapi-auth-jwt2.js</code> ：</p>
          <pre><code class="language-javascript">const env = require(&#39;../dotenv&#39;);

const validate = (decoded, request, callback) =&gt; {
    let error;
    /*
      接口 POST /users/createJWT 中的 jwt 签发规则

      const payload = {
        userId: jwtInfo.userId,
        exp: Math.floor(new Date().getTime() / 1000) + 7 * 24 * 60 * 60,
      };
      return JWT.sign(payload, process.env.JWT_SECRET);
    */

    // decoded 为 JWT payload 被解码后的数据
    const { userId } = decoded;

    if (!userId) {
        return callback(error, false, userId);
    }
    const credentials = {
        userId,
    };
    // 在路由接口的 handler 通过 request.auth.credentials 获取 jwt decoded 的值
    return callback(error, true, credentials);
};

module.exports = (server) =&gt; {
    server.auth.strategy(&#39;jwt&#39;, &#39;jwt&#39;, {
        key: env.JWT_SECRET,
        validate: validate,
    });
    server.auth.default(&#39;jwt&#39;);
};
</code></pre>
          <p>在 <code>app.js</code> 中注册 <code>hapi-auth-jwt2</code> 插件，<code>hapi-auth-jwt2</code> 的注册使用方式与其他插件略有不同，是在插件完成 <code>register</code> 注册之后，通过获取 <code>server</code> 实例后才完成最终的配置，所以，在代码书写上，存在一个先后顺序问题。</p>
          <pre><code class="language-javascript">const Hapi = require(&#39;@hapi/hapi&#39;);
const hapiAuthJWT2 = require(&#39;hapi-auth-jwt2&#39;);

// 引入路由
const routesHelloHapi = require(&#39;./routes/hello-hapi&#39;);
const routesUsers = require(&#39;./routes/users&#39;);

// 引入自定义的 hapi-swagger 插件配置
const pluginHapiSwagger = require(&#39;./plugins/hapi-swagger&#39;);
// 引入自定义的 hapi-pagination 插件配置
const pluginHapiPagination = require(&#39;./plugins/hapi-pagination&#39;);
// 引入自定义的 hapi-auth-jwt2 插件配置
const pluginHapiAuthJWT2 = require(&#39;./plugins/hapi-auth-jwt2&#39;);

// 载入环境配置文件
const env = require(&#39;./dotenv&#39;);

const init = async () =&gt; {

    const server = Hapi.server({
        port: env.SERVER_PORT,
        host: env.SERVER_HOST
    });

    // 注册插件
    await server.register([
        // 为系统使用 hapi-swagger
        ...pluginHapiSwagger,
        // 为系统使用 hapi-pagination
        pluginHapiPagination,
        // 为系统使用 hapi-auth-jwt2
        hapiAuthJWT2,
    ]);

    // 载入身份验证插件
    pluginHapiAuthJWT2(server);

    server.route([
        ...routesHelloHapi,
        ...routesUsers,
    ]);

    await server.start();
    console.log(&#39;Server running on %s&#39;, server.info.uri);
};

process.on(&#39;unhandledRejection&#39;, (err) =&gt; {

    console.log(err);
    process.exit(1);
});

init();
</code></pre>
          <p>一旦在 <code>app.js</code> 中，引入 <code>hapi-auth-jwt</code> 插件后，所有的接口都默认开启 <code>JWT</code> 认证（接口配置 <code>auth: &#39;jwt&#39;</code>），需要在接口调用的过程中，在 <code>header</code> 中添加带有 <code>JWT</code> 的 <code>authorization</code> 的字段。此时通过 <code>Swagger</code> 文档访问先前的 <code>users</code> 任意接口，由于没有传输 <code>JWT</code> ，接口都会返回 <code>401</code> 的错误。</p>
          <pre><code class="language-json">{
    &quot;statusCode&quot;: 401,
    &quot;error&quot;: &quot;Unauthorized&quot;,
    &quot;message&quot;: &quot;Missing authentication&quot;
}
</code></pre>
          <p>如果希望一些特定接口不通过 <code>JWT</code> 验证，可以在 <code>router</code> 中的 <code>options</code> 定义 <code>auth: false</code> 的配置，再通过 <code>Swagger</code> 文档试试对应配置的接口。同步更新 <code>validate</code> 中针对 <code>authorization</code> 的 <code>header</code> 入参校验，在 <code>Swagger</code> 文档中也会同步自动更新。</p>
          <pre><code class="language-javascript">options: {
  validate: {
    headers: Joi.object({
      authorization: Joi.string().required(),
    }).unknown(),
  }
}
</code></pre>
          <p><strong>迅速重构整理公共的 header 定义</strong></p>
          <p>编写 <code>utils/router-helper.js</code> 文件实现公用业务：</p>
          <pre><code class="language-javascript">const Joi = require(&#39;@hapi/joi&#39;);

const paginationDefine = {
    limit: Joi.number().integer().min(1).default(10).description(&#39;每页的条目数&#39;),
    page: Joi.number().integer().min(1).default(1).description(&#39;页码数&#39;),
    pagination: Joi.boolean().description(&#39;是否开启分页，默认为true&#39;),
};

const jwtHeaderDefine = {
    headers: Joi.object({
        authorization: Joi.string().required(),
    }).unknown(),
};

module.exports = {paginationDefine, jwtHeaderDefine};
</code></pre>
          <p>在需要使用到 <code>authorization</code> 的 <code>header</code> 配置处只需要使用如下语法即可：</p>
          <pre><code class="language-javascript">options: {
  validate: {
    ...jwtHeaderDefine
  }
}
</code></pre>
          <p><strong>handler 中使用 JWT 的获取 userId</strong></p>
          <p>在 <code>plugins/hapi-auth-jwt2.js</code> 会通过 <code>callback(error, true, credentials)</code> 的第三个参数，将 <code>JWT</code> 解码过所需要露出的数据字段与值追加到 <code>request.auth</code> 中，然后在路由 <code>handler</code> 的生命周期中，通过 <code>request.auth.credentials</code> 来获取对应的信息。使用 <code>POST /users/createJWT</code> 来生成一段 <code>JWT</code>。 再通过 <code>routes/hello-hapi.js</code> 的接口 <code>/restricted</code> 做一个实验性验证，修改 <code>plugins/hapi-auth-jwt2.js</code> 内容：</p>
          <pre><code class="language-javascript">const env = require(&#39;../dotenv&#39;);

const validate = async (decoded, request, h) =&gt; {
    let error;
    /*
      接口 POST /users/createJWT 中的 jwt 签发规则

      const payload = {
        userId: jwtInfo.userId,
        exp: Math.floor(new Date().getTime() / 1000) + 7 * 24 * 60 * 60,
      };
      return JWT.sign(payload, process.env.JWT_SECRET);
    */

    // decoded 为 JWT payload 被解码后的数据
    const { userId } = decoded;

    if (!userId) {
        return callback(error, false, userId);
    }

    // 验证数字是否有效
    if (!userId) {
        return {isValid: false};
    } else {
        return {isValid: true};
    }
};

module.exports = (server) =&gt; {
    server.auth.strategy(&#39;jwt&#39;, &#39;jwt&#39;, {
        key: env.JWT_SECRET,
        validate,
    });
    server.auth.default(&#39;jwt&#39;);
};
</code></pre>
          <p>然后编写 <code>/restricted</code> 接口测试验证，编写 <code>routes/hello-hapi.js</code> ：</p>
          <pre><code class="language-javascript">const {jwtHeaderDefine} = require(&#39;../utils/router-helper&#39;);

module.exports = [
    {
        method: &#39;GET&#39;,
        path: &#39;/restricted&#39;,
        options: {
            handler: (request, h) =&gt; {
                const response = h.response({
                    message: &#39;您使用有效的JWT令牌来访问限制接口！&#39;
                });
                response.header(&quot;Authorization&quot;, request.headers.authorization);
                console.log(&#39;输出信息：&#39;, request.auth.credentials); // 控制台输出 { userId: 1}
                return &#39;hello hapi&#39;;
            },
            auth: &#39;jwt&#39;,
            description: &#39;用于测试的用户 JWT 签发&#39;,
            notes: &#39;这是用于测试的用户 JWT 签发信息展示笔记&#39;,
            tags: [&#39;api&#39;, &#39;test&#39;],
            validate: {
                ...jwtHeaderDefine, // 增加需要 jwt auth 认证的接口 header 校验
            }
        },
    },
];
</code></pre>
          <p>重启项目后使用系统 <code>PowerShell</code> 或者 <code>Bash</code> 终端进行测试：</p>
          <pre><code class="language-bash">curl -v -H &quot;Authorization: 控制台输出的Token值&quot; http://localhost:3000/restricted

#例如：
curl -v -H &quot;Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwibmFtZSI6IkFudGhvbnkgVmFsaWQgVXNlciIsImlhdCI6MTU2Mzk1ODkwNn0.X-YfqA850TVQdV6KyGypEQSzJ_6f5A_-PTzAVM5yobk&quot; http://localhost:3000/restricted
</code></pre>
          <p>如果返回信息：</p>
          <pre><code class="language-bash">$ curl -v -H &quot;Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwibmFtZSI6IkFudGhvbnkgVmFsaWQgVXNlciIsImlhdCI6MTU2Mzk1ODkwNn0.X-YfqA850TVQ
dV6KyGypEQSzJ_6f5A_-PTzAVM5yobk&quot; http://localhost:3000/restricted
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 3000 (#0)
&gt; GET /restricted HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/7.58.0
&gt; Accept: */*
&gt; Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwibmFtZSI6IkFudGhvbnkgVmFsaWQgVXNlciIsImlhdCI6MTU2Mzk1ODkwNn0.X-YfqA850TVQdV6KyGypEQSzJ_6f5A_-PTzAVM5yobk
&gt;
&lt; HTTP/1.1 200 OK
&lt; authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwibmFtZSI6IkFudGhvbnkgVmFsaWQgVXNlciIsImlhdCI6MTU2Mzk1ODkwNn0.X-YfqA850TVQdV6KyGypEQSzJ_6f5A_-PTzAVM5yobk
&lt; content-type: application/json; charset=utf-8
&lt; cache-control: no-cache
&lt; content-length: 65
&lt; accept-ranges: bytes
&lt; Date: Wed, 24 Jul 2019 09:02:34 GMT
&lt; Connection: keep-alive
&lt;
* Connection #0 to host localhost left intact
{&quot;message&quot;:&quot;您使用有效的JWT令牌来访问限制接口！&quot;}
</code></pre>
          <p>看到成功结果说明通过了。</p>
          <p><strong>JWT 项目运用</strong></p>
          <p>如果在项目实战使用大多数都是登录这边，当用户访问登录接口的时候，后端校验用户信息正确后，返回用户基本信息，例如：用户ID、用户权限等级、用户角色等级等等签发 <code>JWT</code> 返回给客户端，这样客户端访问其他接口，例如访问编辑用户信息的接口不需要传参用户ID，因为在 <code>header</code> 头有个 <code>Authorization</code> 字段包含基本信息，大大减少前后端判断工作量。</p>
          <h3 id="理解事务的使用场景">理解事务的使用场景</h3>
          <p>例如现在有个创建订单系统，包含 <code>orders</code> 表和 <code>order_goods</code> 表。</p>
          <p>下面这个表是 <code>orders</code> 表描述：</p>
          <table>
            <thead>
            <tr>
              <th align="center">字段</th>
              <th align="center">字段类型</th>
              <th align="center">字段类型</th>
            </tr>
            </thead>
            <tbody>
            <tr>
              <td align="center">id</td>
              <td align="center">integer</td>
              <td align="center">订单的 ID，自增</td>
            </tr>
            <tr>
              <td align="center">user_id</td>
              <td align="center">integer</td>
              <td align="center">用户的 ID</td>
            </tr>
            <tr>
              <td align="center">payment_status</td>
              <td align="center">enum</td>
              <td align="center">付款状态</td>
            </tr>
            </tbody>
          </table>
          <p>下面这个表是 <code>order_goods</code> 表描述：</p>
          <table>
            <thead>
            <tr>
              <th align="center">字段</th>
              <th align="center">字段类型</th>
              <th align="center">字段类型</th>
            </tr>
            </thead>
            <tbody>
            <tr>
              <td align="center">id</td>
              <td align="center">integer</td>
              <td align="center">订单商品的 ID，自增</td>
            </tr>
            <tr>
              <td align="center">order_id</td>
              <td align="center">integer</td>
              <td align="center">订单的 ID</td>
            </tr>
            <tr>
              <td align="center">goods_id</td>
              <td align="center">integer</td>
              <td align="center">商品的 ID</td>
            </tr>
            <tr>
              <td align="center">single_price</td>
              <td align="center">float</td>
              <td align="center">商品的价格</td>
            </tr>
            <tr>
              <td align="center">count</td>
              <td align="center">integer</td>
              <td align="center">商品的数量</td>
            </tr>
            </tbody>
          </table>
          <p>从表结构的设计关系来看，创建一次订单，依赖于先创建产生一条 <code>orders</code> 表的记录，获得一个 <code>order_id</code>, 然后在 <code>order_goods</code> 表中通过 <code>order_id</code> 插入订单中的每一条商品记录，以最终完成一次完整的订单创建行为。中途若商品记录的插入遇到了失败，则一个订单记录的创建行为便是不完整的，<code>orders</code> 表中却产生了一条数据不完整的垃圾数据。在这样的场景下可以尝试引入事务操作。</p>
          <p>数据库中的事务是指单个逻辑所包含的一系列数据操作，要么全部执行，要么全部不执行。在一个事务中，可能会包含开始（start）、提交（commit）、回滚（rollback）等操作，<code>Sequelize</code> 通过 Transaction 类来实现事务相关功能。以满足一些对操作过程的完整性比较高的使用场景。</p>
          <p><code>Sequelize</code> 支持两种使用事务的方法：</p>
          <ul>
            <li>托管事务</li>
            <li>非托管事务</li>
          </ul>
          <p>托管事务基于 <code>Promise</code> 结果链进行自动提交或回滚。非托管事务则交由用户自行控制提交或回滚。</p>
          <p><strong>使用托管事务创建订单</strong></p>
          <pre><code class="language-javascript">handler: async (request, h) =&gt; {
    await models.sequelize.transaction((t) =&gt; {
        return models.orders.create(
            {user_id: request.auth.credentials.userId}, // 从 JWT 获取用户id
            {transaction: t},
        ).then((order) =&gt; {
            const goodsList = [];
            request.payload.goodsList.forEach((item) =&gt; {
                goodsList.push(models.order_goods.create({
                    order_id: order.dataValues.id,
                    goods_id: item.goods_id,
                    // 此处单价的数值应该从商品表中反查出写入
                    goods_price: 4.9,
                    count: item.count,
                }));
            });
            return Promise.all(goodsList);
        });
    }).then(() =&gt; {
        // 事务已被提交
        return &#39;success&#39;;
    }).catch(() =&gt; {
        // 事务已被回滚
        return &#39;error&#39;;
    });
}
</code></pre>
          <p>无论是托管事务还是非托管事务，只要 <code>sequelize.transaction</code> 中抛出异常，<code>sequelize.transaction</code> 中所有关于数据库的操作都将被回滚。</p>
          <p>更多功能请查看官方手册 <a href="http://docs.sequelizejs.com/manual/transactions.html">Transactions </a>。</p>
          <h3 id="系统监控和记录">系统监控和记录</h3>
          <p>在上述文章把后端开发核心重要点描述差不多，大多数系统过程都是这样。当系统上线的时候需要了解系统的状况情况，这时候需要一些插件辅助来得知系统运行情况，<code>hapi</code> 提供的用于检索和打印日志的内置方法非常少，要获得功能更丰富的日志记录体验可以使用 <a href="https://github.com/hapijs/good">Good</a> 插件，<code>Good</code> 是一个 <code>hapi</code> 插件，用于监视和报告来自主机的各种 <code>hapi</code> 服务器事件以及 <code>ops</code> 信息。它侦听 <code>hapi</code> 服务器实例发出的事件，并将标准化事件推送到流集合中。<code>Good</code> 插件目前有这四个扩展功能： <a href="https://github.com/hapijs/good-squeeze">good-squeeze</a>、<a href="https://github.com/hapijs/good-console">good-console</a>、good-file、good-http。</p>
          <pre><code class="language-bash">npm install @hapi/good --save
npm install @hapi/good-squeeze --save
npm install @hapi/good-console --save
</code></pre>
          <p>配置插件 <code>plugins/hapi-good.js</code>：</p>
          <pre><code class="language-javascript">const hapiGood = require(&#39;@hapi/good&#39;);

const options = {
    ops: {
        interval: 1000
    },
    reporters: {
        myConsoleReporter: [
            {
                module: &#39;@hapi/good-squeeze&#39;,
                name: &#39;Squeeze&#39;,
                args: [{ log: &#39;*&#39;, response: &#39;*&#39; }]
            },
            {
                module: &#39;@hapi/good-console&#39;
            },
            &#39;stdout&#39;
        ]
    }
};

module.exports = {
    plugin: hapiGood,
    options: options,
};
</code></pre>
          <p>然后在 <code>app.js</code> 引入注册就可以了，在控制台可以看到系统日志信息，当然在 <code>Hapi</code> 文档插件列表还有更多插件，这里就不再详细描述，可以找个合适的体验下。</p>
          <h3 id="系统稳定性测试">系统稳定性测试</h3>
          <p>测试框架，是运行测试的工具。通过它可以为 <code>JavaScript</code> 应用添加测试，从而保证代码的质量。现行的 <code>Javascript</code> 常用流行测试库有 <code>Jasmine</code>，<code>Mocha</code>， <code>Karma</code> 等，虽然框架的名称不同，但背后的核心套件却大同小异。</p>
          <p><strong>Lab</strong></p>
          <p><a href="https://github.com/hapijs/lab">Lab</a> 库支持 <code>async/await</code>，尽可能保持测试引擎的足够简单，并包含了现代 <code>Node.js</code> 测试框架程序中需要的所有特性。提供了 <code>describe</code> 和 <code>it</code>，以及生命周期的钩子等功能。</p>
          <p><strong>Code</strong></p>
          <p><code>Code</code> 库用于提供 <code>expect</code> 断言的相关函数库，<code>code-expect</code> 与 <code>mocha-expect</code> 用法上几乎完全一致。</p>
          <pre><code class="language-bash">npm install --save-dev @hapi/lab
npm install --save-dev @hapi/code
</code></pre>
          <p>然后在项目 <code>test/unit.js</code> 编写实例：</p>
          <pre><code class="language-javascript">const { expect } = require(&#39;@hapi/code&#39;);
const { it } = exports.lab = require(&#39;@hapi/lab&#39;).script();

it(&#39;returns true when 1 + 1 equals 2&#39;, () =&gt; {
    expect(1 + 1).to.equal(2);
});
</code></pre>
          <p>运行终端命令：</p>
          <pre><code class="language-bash">$ lab ./test/unit.js
1 tests complete
Test duration: 8 ms
Leaks: No issues
</code></pre>
          <p><strong>测试接口</strong></p>
          <pre><code class="language-javascript">&#39;use strict&#39;;

const Lab = require(&#39;@hapi/lab&#39;);
const { expect } = require(&#39;@hapi/code&#39;);
const { afterEach, beforeEach, describe, it } = exports.lab = Lab.script();
const { init } = require(&#39;../lib/server&#39;);

describe(&#39;GET /&#39;, () =&gt; {
    let server;

    beforeEach(async () =&gt; {
        server = await init();
    });

    afterEach(async () =&gt; {
        await server.stop();
    });

    it(&#39;responds with 200&#39;, async () =&gt; {
        const res = await server.inject({
            method: &#39;get&#39;,
            url: &#39;/&#39;
        });
        expect(res.statusCode).to.equal(200);
    });
});
</code></pre>
          <h3 id="总结">总结</h3>
          <p><strong>热重载</strong></p>
          <p>上述开发流程大致是这样，继续完善开发过程所遇到的问题，现在有个问题每当编写好文件，还得需要重启服务才能看到改动效果，要实现热加载很简单，可以安装 <code>nodemon</code> 插件完成需求：</p>
          <pre><code class="language-bash">npm install --save-dev nodemon
</code></pre>
          <p>修改 <code>package.json</code> 字段：</p>
          <pre><code class="language-json">&quot;scripts&quot;: {
  &quot;dev&quot;: &quot;nodemon --inspect ./app.js&quot;,
},
</code></pre>
          <p>更多内容请参考文档：<a href="https://github.com/remy/nodemon">nodemon</a></p>
          <p>已上传到 Github：<a href="https://github.com/JaxsonWang/Api-test">Api-test</a></p>
          <!--删除上面测试数据--><!--删除上面测试数据--><!--删除上面测试数据--><!--删除上面测试数据--><!--删除上面测试数据-->
        </section>
      </article>
      <ul class="post-copyright">
        <li class="post-copyright-author">
          <strong>文章作者： </strong>淮城一只猫</li>
        <li class="post-copyright-link">
          <strong>文章链接：</strong>
          <a href="https://iiong.com/xxxxxxxxxxxx.html" title="文章标题">https://iiong.com/xxxxxxxxxxxx.html</a>
        </li>
        <li class="post-copyright-license">
          <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
        </li>
      </ul>
      <div class="post-comments">
        <!-- 这里放置评论框 -->
        这里放置评论框，用于第三方评论或者博客平台评论。评论框样式可以自己自由发挥定制！
      </div>
    </div>
  </main>
  <footer class="site-footer">
    <div class="container d-flex justify-content-sm-between justify-content-center text-center">
      <div class="copyright">
        <p>Powered by Ghost. Copyright &copy; 2019. Crafted with Frenemy.</p>
      </div>
      <nav class="social-links d-none d-sm-block">
        <ul>
          <li class="social-link"><a href="#"><i class="fab fa-weibo"></i></a></li>
          <li class="social-link"><a href="#"><i class="fab fa-twitter"></i></a></li>
        </ul>
      </nav>
    </div>
  </footer>
  <div id="return-to-top" class="animated"><i class="fas fa-angle-double-up"></i></div>
</div>

<script type="text/javascript" src="assets/jquery/jquery.js"></script>
<script type="text/javascript" src="assets/bootstrap/bootstrap.js"></script>
<script type="text/javascript" src="assets/pivot/pivot.js"></script>
<script type="text/javascript" src="assets/app/js/app.min.js?ver=1153"></script>
<script type="text/javascript" src="./demo.js"></script>
</body>
</html>
